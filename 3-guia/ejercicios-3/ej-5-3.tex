\begin{enunciado}{\ejercicio}
  Dado el siguiente programa en lenguaje C.
  \begin{cLang}[linewidth=6cm]
int x = 2;
int y = 32;
x = x + y ;
  \end{cLang}

  \begin{enumerate}[label=\alph*)]
    \item Traducir a lenguaje esamblador de RISC-V. Usar los registros t0 y t1 inicializados con
          números de 8 bits para representar a las variables x e y respectivamente.

    \item  Escribir un programa que guarde en t2 un numero de 32 bits divido en sus 12 bits más
          significativos en t0 y el resto de 20 bits en \textbf{t1}.

    \item ¿Cómo maneja RISC-V la extensión de signo en los inmediatos de 12 bits? ¿Qué resultado
          generaría la instrucción  \textbf{andi} a0, a0, -2048 cuando a0 vale 0xFFFFFFFF? Re-escribir
          el código del inciso  \textbf{a)} para números de 32 bits sin utilizar la instrucción  \textbf{li}.
  \end{enumerate}
\end{enunciado}

\begin{enumerate}[label=\alph*)]
  \item \
        \begin{center}
          \begin{riscv}[linewidth=6cm]
li t0, 2
li t1, 32
add t0, t0, t1
          \end{riscv}
        \end{center}
  \item \hacer
  \item RISC V maneja la extensión de los signos en los inmediatos, completando con el bit más significativos
        del inmediato.
        La instruccion \textbf{andi} a0, a0, -2048 si a0 vale 0xFFFFFFFF sería el valor de -2048 en 32 bits, que  en
        hexadecimal es:  $\neg$ 0x0000 0800 $+ 1$ = 0xFFFF F000

        \begin{enumerate}
          \item  \ 
\begin{riscv}
addi t0, zero, 2
addi t1, zero, 32
add t0, t0, t1
                \end{riscv}
        \end{enumerate}
\end{enumerate}
